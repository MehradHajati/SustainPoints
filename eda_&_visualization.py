# -*- coding: utf-8 -*-
"""EDA & Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UKm97Jm55ZSHgqUpZisqiLJpFON_Tk-A
"""

"""
EDA & Visualization utilities for SustainPoints.

This module:
- Normalizes/auto-tags categories from Description where needed
- Provides reusable chart functions for:
    - Overall transaction & points trends
    - Category & subcategory breakdowns
    - Utilities (electricity / water)
    - Fuel vs EV vs Transit
    - Solar / green upgrades
    - Green vs other spend
- Exposes `render_chart_for_question` for LLM integration.

Usage (example):

    from eda_charts import (
        plot_transactions_over_time,
        plot_monthly_total_points,
        plot_spend_by_category_bar,
        render_chart_for_question,
    )

    plot_transactions_over_time(df_points)
    render_chart_for_question(df_points, "Show my fuel vs EV vs transit mix")

Assumptions:
- df must contain a 'Date' column.
- 'Category', 'Subcategory', 'Points', 'PointType' are optional and enriched when missing.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# ==========================
# Helpers & styling
# ==========================


def _base_style():
    """Base Matplotlib style used for all charts."""
    plt.rcParams.update({
        "figure.figsize": (9, 4.8),
        "axes.titlesize": 13,
        "axes.titleweight": "bold",
        "axes.labelsize": 10,
        "xtick.labelsize": 9,
        "ytick.labelsize": 9,
        "axes.grid": True,
        "grid.alpha": 0.25,
    })


def _ensure_datetime(df: pd.DataFrame) -> pd.DataFrame:
    """Ensure df['Date'] is datetime."""
    if "Date" not in df.columns:
        raise ValueError("Expected a 'Date' column in DataFrame.")
    out = df.copy()
    if not pd.api.types.is_datetime64_any_dtype(out["Date"]):
        out["Date"] = pd.to_datetime(out["Date"], errors="coerce")
    return out


CATEGORY_DISPLAY_MAP = {
    "CIRCULAR": "REUSE & RECYCLING",
    "GREEN_UPGRADES": "GREEN UPGRADES",
}


def _display_label(cat) -> str:
    """Human-friendly category label for plots."""
    if pd.isna(cat):
        return "Uncategorized"
    return CATEGORY_DISPLAY_MAP.get(str(cat), str(cat))


def auto_tag_categories(df: pd.DataFrame) -> pd.DataFrame:
    """
    Auto-fill Category/Subcategory based on Description where missing.

    This is heuristic and safe to run on top of existing labels:
    it only fills NaNs in Category/Subcategory.
    """
    if "Description" not in df.columns:
        return df

    out = df.copy()

    if "Category" not in out.columns:
        out["Category"] = np.nan
    if "Subcategory" not in out.columns:
        out["Subcategory"] = np.nan

    desc = out["Description"].astype(str).str.lower()

    def set_cat(mask, cat=None, sub=None):
        if cat is not None:
            out.loc[mask & out["Category"].isna(), "Category"] = cat
        if sub is not None:
            out.loc[mask & out["Subcategory"].isna(), "Subcategory"] = sub

    # Groceries
    set_cat(desc.str.contains("superstore|sobeys|walmart|no frills|grocery|supermarket"),
            "GROCERIES", None)

    # Fuel / EV / Transit
    set_cat(desc.str.contains("gas station|petro-canada|shell|esso|fuel"),
            "TRANSPORT", "FUEL_PETROL_DIESEL")
    set_cat(desc.str.contains("ev charge|charging station"),
            "TRANSPORT", "FUEL_EV")
    set_cat(desc.str.contains("monthly bus pass|halifax transit"),
            "TRANSPORT", "BUS_PASS")
    set_cat(desc.str.contains("transit reload"),
            "TRANSPORT", "TRANSIT_RELOAD")

    # Utilities
    set_cat(desc.str.contains("electricity bill|nova scotia power"),
            "UTILITIES", "ELECTRICITY")
    set_cat(desc.str.contains("water bill|halifax water"),
            "UTILITIES", "WATER")

    # Solar & efficiency
    set_cat(desc.str.contains("solar"),
            "GREEN_UPGRADES", "SOLAR")
    set_cat(desc.str.contains("heat pump|insulation|energy audit"),
            "GREEN_UPGRADES", "EFFICIENCY")

    # Thrift / second-hand
    set_cat(desc.str.contains("thrift|consignment|value village|second hand|used "),
            "CIRCULAR", "THRIFT_REFURB")

    # Bottle returns
    set_cat(desc.str.contains("bottle return credit|bottle deposit refund|recycling centre refund"),
            "CIRCULAR", "BOTTLE_RETURN")

    return out


# ==========================
# Core charts
# ==========================


def plot_transactions_over_time(df: pd.DataFrame):
    """Line chart: number of transactions per month."""
    df = _ensure_datetime(df)
    _base_style()
    monthly = df.groupby(pd.Grouper(key="Date", freq="M")).size()

    if monthly.empty:
        print("No data for transactions over time.")
        return

    plt.figure()
    plt.plot(monthly.index, monthly.values, marker="o", linewidth=2)
    plt.fill_between(monthly.index, monthly.values, alpha=0.1)
    plt.title("Number of Transactions per Month")
    plt.xlabel("Month")
    plt.ylabel("Count")
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()


def plot_monthly_total_points(df: pd.DataFrame):
    """Line + area: sustainability points per month."""
    if "Points" not in df.columns:
        print("No 'Points' column; skipping monthly points chart.")
        return

    df = _ensure_datetime(df)
    _base_style()
    monthly = df.groupby(pd.Grouper(key="Date", freq="M"))["Points"].sum().reset_index()

    if monthly["Points"].sum() == 0:
        print("No points to plot.")
        return

    plt.figure()
    plt.plot(monthly["Date"], monthly["Points"], marker="o", linewidth=2.5)
    plt.fill_between(monthly["Date"], monthly["Points"], alpha=0.15)

    ymax = monthly["Points"].max()
    offset = ymax * 0.04 if ymax > 0 else 1.0
    for x, y in zip(monthly["Date"], monthly["Points"]):
        plt.text(x, y + offset, f"{int(y)}", ha="center", va="bottom", fontsize=8)

    plt.title("Total Sustainability Points per Month")
    plt.xlabel("Month")
    plt.ylabel("Points")
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()


def plot_spend_by_category_bar(df: pd.DataFrame, top_n: int = 15):
    """Bar: total Debit by Category."""
    if "Debit" not in df.columns:
        print("No 'Debit' column; cannot plot spending by category.")
        return

    df = auto_tag_categories(df)
    _base_style()

    totals = (
        df.groupby("Category")["Debit"]
        .sum()
        .sort_values(ascending=False)
        .head(top_n)
    )

    if totals.empty:
        print("No spend data by category.")
        return

    labels = [_display_label(c) for c in totals.index]
    colors = plt.cm.tab20(np.linspace(0, 1, len(labels)))

    plt.figure()
    plt.bar(labels, totals.values, color=colors, edgecolor="black", linewidth=0.5)
    plt.title("Total Spending by Category (Top {})".format(top_n))
    plt.xlabel("Category")
    plt.ylabel("Total Debit")
    plt.xticks(rotation=45, ha="right")
    plt.tight_layout()
    plt.show()


def plot_points_by_category_pie(df: pd.DataFrame, min_slice_pct: float = 3.0):
    """Pie: total Points by Category."""
    if "Points" not in df.columns:
        print("No 'Points' column; cannot plot points by category.")
        return

    df = auto_tag_categories(df)
    _base_style()

    cat = df.groupby("Category")["Points"].sum().sort_values(ascending=False)
    total = cat.sum()
    if total <= 0:
        print("No points for category pie.")
        return

    labels, values, other = [], [], 0.0
    for raw_label, val in cat.items():
        pct = (val / total) * 100.0
        label = _display_label(raw_label)
        if pct < min_slice_pct:
            other += val
        else:
            labels.append(label)
            values.append(val)

    if other > 0:
        labels.append("Other")
        values.append(other)

    plt.figure(figsize=(7, 7))
    colors = plt.cm.Set3(np.linspace(0, 1, len(values)))
    wedges, texts, autotexts = plt.pie(
        values,
        labels=labels,
        colors=colors,
        autopct="%1.1f%%",
        startangle=140,
        pctdistance=0.8,
        labeldistance=1.05,
        wedgeprops={"edgecolor": "white", "linewidth": 1.5},
        textprops={"fontsize": 10},
    )
    for a in autotexts:
        a.set_fontweight("bold")

    plt.title("Points by Category")
    plt.axis("equal")
    plt.tight_layout()
    plt.show()


def plot_boxplot_amounts_by_category(df: pd.DataFrame, min_count: int = 30):
    """Boxplot: Debit distribution per Category (only where we have enough rows)."""
    if "Debit" not in df.columns:
        print("No 'Debit' column; cannot plot boxplots.")
        return

    df = auto_tag_categories(df)
    _base_style()

    data, labels = [], []
    for cat, g in df.groupby("Category"):
        vals = g["Debit"].dropna()
        if len(vals) >= min_count:
            data.append(vals)
            labels.append(_display_label(cat))

    if not data:
        print("Not enough data per category for boxplots.")
        return

    plt.figure(figsize=(10, 5))
    box = plt.boxplot(data, showfliers=False, patch_artist=True)
    colors = plt.cm.Blues(np.linspace(0.4, 0.9, len(data)))
    for patch, color in zip(box["boxes"], colors):
        patch.set(facecolor=color, alpha=0.9)

    plt.xticks(range(1, len(labels) + 1), labels, rotation=45, ha="right")
    plt.title("Debit Amount Distribution by Category")
    plt.ylabel("Debit")
    plt.tight_layout()
    plt.show()


def plot_monthly_category_stack(df: pd.DataFrame, use_points: bool = False, top_n: int = 6):
    """
    Stacked area:
    - x: Month
    - y: Debit or Points
    - stack: top N Categories (+ Other).
    """
    metric = "Points" if use_points else "Debit"
    if metric not in df.columns:
        print(f"No '{metric}' column; cannot plot stacked chart.")
        return

    df = auto_tag_categories(_ensure_datetime(df))
    _base_style()

    pivot = df.pivot_table(
        index=pd.Grouper(key="Date", freq="M"),
        columns="Category",
        values=metric,
        aggfunc="sum",
        fill_value=0.0,
    )

    if pivot.empty:
        print("No data for stacked chart.")
        return

    top_categories = pivot.sum().sort_values(ascending=False).head(top_n).index
    others = pivot.columns.difference(top_categories)

    pivot_top = pivot[top_categories].copy()
    if len(others) > 0:
        pivot_top["Other"] = pivot[others].sum(axis=1)

    plt.figure()
    plt.stackplot(pivot_top.index, pivot_top.T.values)
    plt.title(f"Monthly {'Points' if use_points else 'Spending'} by Category (Stacked)")
    plt.xlabel("Month")
    plt.ylabel(metric)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()


def plot_top_merchants(df: pd.DataFrame, n: int = 15, category_filter: str = None):
    """Horizontal bar: most frequent merchants / descriptions."""
    if "Description" not in df.columns:
        print("No 'Description' column; cannot plot merchants.")
        return

    _base_style()
    data = df
    if category_filter and "Category" in df.columns:
        data = df[df["Category"] == category_filter]

    counts = data["Description"].value_counts().head(n)
    if counts.empty:
        print("No merchants to plot.")
        return

    plt.figure(figsize=(9, 5))
    plt.barh(counts.index.astype(str), counts.values)
    plt.gca().invert_yaxis()
    plt.title(
        "Top Merchants / Descriptions"
        + (f" – {category_filter}" if category_filter else "")
    )
    plt.xlabel("Count")
    plt.tight_layout()
    plt.show()


# ==========================
# Sustainability-focused charts
# ==========================


def plot_fuel_type_breakdown(df: pd.DataFrame):
    """Bar: total Debit for each transport mode (fuel, EV, bus, reloads)."""
    if "Debit" not in df.columns:
        print("No 'Debit' column; cannot plot fuel breakdown.")
        return

    df = auto_tag_categories(df)
    _base_style()

    mapping = {
        "FUEL_PETROL_DIESEL": "Fuel (Petrol/Diesel)",
        "FUEL_EV": "Fuel (EV Charging)",
        "BUS_PASS": "Public Transit Pass",
        "TRANSIT_RELOAD": "Public Transit Reload",
    }

    totals = {}
    if "Subcategory" in df.columns:
        for code, label in mapping.items():
            mask = df["Subcategory"] == code
            if mask.any():
                totals[label] = df.loc[mask, "Debit"].sum()

    if not totals:
        print("No fuel/transport-related rows detected.")
        return

    labels = list(totals.keys())
    values = list(totals.values())
    colors = plt.cm.Paired(np.linspace(0, 1, len(labels)))

    plt.figure(figsize=(7, 4))
    plt.bar(labels, values, color=colors, edgecolor="black", linewidth=0.5)
    plt.title("Transport Spend by Mode / Fuel Type")
    plt.ylabel("Total Debit")
    plt.xticks(rotation=20, ha="right")
    plt.tight_layout()
    plt.show()


def plot_utility_trends(df: pd.DataFrame):
    """Line: electricity vs water spend per month."""
    if "Debit" not in df.columns:
        print("No 'Debit' column; cannot plot utilities.")
        return

    df = auto_tag_categories(_ensure_datetime(df))
    _base_style()

    util = df[df["Category"] == "UTILITIES"]
    if util.empty:
        print("No utilities detected.")
        return

    pivot = util.pivot_table(
        index=pd.Grouper(key="Date", freq="M"),
        columns="Subcategory",
        values="Debit",
        aggfunc="sum",
        fill_value=0.0,
    )

    if pivot.empty:
        print("No utility trends to plot.")
        return

    plt.figure()
    colors = plt.cm.coolwarm(np.linspace(0, 1, len(pivot.columns)))
    for col, color in zip(pivot.columns, colors):
        plt.plot(pivot.index, pivot[col], marker="o", linewidth=2, label=str(col), color=color)

    plt.title("Monthly Utility Spend by Type")
    plt.xlabel("Month")
    plt.ylabel("Debit")
    plt.xticks(rotation=45)
    plt.legend()
    plt.tight_layout()
    plt.show()


def plot_solar_investment_timeline(df: pd.DataFrame):
    """Stem plot: discrete solar / green-upgrade spends across time."""
    if "Debit" not in df.columns:
        print("No 'Debit' column; cannot plot solar investments.")
        return

    df = auto_tag_categories(_ensure_datetime(df))
    _base_style()

    if "Subcategory" not in df.columns:
        print("No 'Subcategory' column; no solar tagging available.")
        return

    solar = df[df["Subcategory"] == "SOLAR"]
    if solar.empty:
        print("No solar-related transactions found.")
        return

    plt.figure()
    markerline, stemlines, baseline = plt.stem(solar["Date"], solar["Debit"])
    plt.setp(stemlines, linewidth=1.5)
    plt.setp(markerline, markersize=6)
    plt.title("Solar / Green Upgrade Investments Over Time")
    plt.xlabel("Date")
    plt.ylabel("Debit")
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()


def plot_electricity_vs_solar_pie(df: pd.DataFrame):
    """Pie: grid electricity vs solar/green energy spend."""
    df = auto_tag_categories(df)
    if "Debit" not in df.columns:
        print("No 'Debit' column; cannot plot electricity vs solar.")
        return

    _base_style()

    mask_grid = (
        (df.get("Category") == "UTILITIES")
        & (df.get("Subcategory") == "ELECTRICITY")
    )
    grid_spend = df.loc[mask_grid, "Debit"].sum()

    mask_solar = df.get("Subcategory") == "SOLAR"
    solar_spend = df.loc[mask_solar, "Debit"].sum()

    if grid_spend == 0 and solar_spend == 0:
        print("No electricity/solar-related spend to compare.")
        return

    labels, values = [], []
    if grid_spend > 0:
        labels.append("Grid Electricity")
        values.append(grid_spend)
    if solar_spend > 0:
        labels.append("Solar / Green Energy")
        values.append(solar_spend)

    colors = plt.cm.Set2(np.linspace(0, 1, len(values)))
    plt.figure(figsize=(6, 6))
    wedges, texts, autotexts = plt.pie(
        values,
        labels=labels,
        colors=colors,
        autopct="%1.1f%%",
        startangle=90,
        pctdistance=0.8,
        labeldistance=1.1,
        wedgeprops={"edgecolor": "white", "linewidth": 1.4},
        textprops={"fontsize": 10},
    )
    for a in autotexts:
        a.set_fontweight("bold")

    plt.title("Electricity vs Solar Spend Mix")
    plt.axis("equal")
    plt.tight_layout()
    plt.show()


def plot_fuel_and_transit_mix_pie(df: pd.DataFrame):
    """Pie: transport energy mix – petrol/diesel vs EV vs public transit."""
    df = auto_tag_categories(df)
    if "Debit" not in df.columns:
        print("No 'Debit' column; cannot plot transport mix.")
        return

    _base_style()
    totals = {}

    if "Subcategory" in df.columns:
        mask_gas = df["Subcategory"] == "FUEL_PETROL_DIESEL"
        if mask_gas.any():
            totals["Fuel (Petrol/Diesel)"] = df.loc[mask_gas, "Debit"].sum()

        mask_ev = df["Subcategory"] == "FUEL_EV"
        if mask_ev.any():
            totals["Fuel (EV Charging)"] = df.loc[mask_ev, "Debit"].sum()

        mask_transit = df["Subcategory"].isin(["BUS_PASS", "TRANSIT_RELOAD"])
        if mask_transit.any():
            totals["Public Transit (Pass + Reload)"] = df.loc[mask_transit, "Debit"].sum()

    if not totals:
        print("No fuel/transport-related transactions detected.")
        return

    labels = list(totals.keys())
    values = list(totals.values())
    colors = plt.cm.Pastel1(np.linspace(0, 1, len(labels)))

    plt.figure(figsize=(7, 7))
    wedges, texts, autotexts = plt.pie(
        values,
        labels=labels,
        colors=colors,
        autopct="%1.1f%%",
        startangle=90,
        pctdistance=0.8,
        labeldistance=1.1,
        wedgeprops={"edgecolor": "white", "linewidth": 1.4},
        textprops={"fontsize": 10},
    )
    for a in autotexts:
        a.set_fontweight("bold")

    plt.title("Transport Energy Mix: Fuel vs EV vs Transit")
    plt.axis("equal")
    plt.tight_layout()
    plt.show()


def plot_green_vs_other_spend_pie(df: pd.DataFrame):
    """
    Pie: green-aligned spend vs everything else.
    Green = EV, transit, thrift/reuse, bottle returns, solar, efficiency, etc.
    """
    df = auto_tag_categories(df)
    if "Debit" not in df.columns:
        print("No 'Debit' column; cannot plot green vs other spend.")
        return

    _base_style()

    green_cats = {"GREEN_UPGRADES"}
    green_subcats = {
        "BUS_PASS",
        "TRANSIT_RELOAD",
        "FUEL_EV",
        "THRIFT_REFURB",
        "BOTTLE_RETURN",
        "SOLAR",
        "EFFICIENCY",
    }

    cat = df.get("Category")
    sub = df.get("Subcategory")

    green_mask = pd.Series(False, index=df.index)
    if cat is not None:
        green_mask |= cat.isin(green_cats)
    if sub is not None:
        green_mask |= sub.isin(green_subcats)

    green_spend = df.loc[green_mask, "Debit"].sum()
    other_spend = df.loc[~green_mask, "Debit"].sum()

    if green_spend == 0 and other_spend == 0:
        print("No debit spend to plot.")
        return

    labels, values = [], []
    if green_spend > 0:
        labels.append("Green-Aligned Spend")
        values.append(green_spend)
    if other_spend > 0:
        labels.append("Other Spend")
        values.append(other_spend)

    colors = plt.cm.Set3(np.linspace(0, 1, len(labels)))
    plt.figure(figsize=(6, 6))
    wedges, texts, autotexts = plt.pie(
        values,
        labels=labels,
        colors=colors,
        autopct="%1.1f%%",
        startangle=90,
        pctdistance=0.8,
        labeldistance=1.1,
        wedgeprops={"edgecolor": "white", "linewidth": 1.4},
        textprops={"fontsize": 10},
    )
    for a in autotexts:
        a.set_fontweight("bold")

    plt.title("Green vs Other Spending")
    plt.axis("equal")
    plt.tight_layout()
    plt.show()


# ==========================
# LLM-friendly router
# ==========================


def render_chart_for_question(df: pd.DataFrame, question: str):
    """
    Route a natural-language question to one or more appropriate charts.

    Intended for use by the LLM layer:
        render_chart_for_question(df_points, user_query)
    """
    q = question.lower()

    # Overall / timeline
    if any(k in q for k in ["overall", "summary", "all data", "overview"]):
        plot_transactions_over_time(df)
        if "Points" in df.columns:
            plot_monthly_total_points(df)
        return

    if any(k in q for k in ["trend", "monthly", "progress", "time series"]):
        if "point" in q:
            plot_monthly_total_points(df)
        else:
            plot_transactions_over_time(df)
        return

    # Categories
    if any(k in q for k in ["category", "categories", "breakdown", "which area"]):
        if "point" in q:
            plot_points_by_category_pie(df)
        else:
            plot_spend_by_category_bar(df)
        return

    # Utilities
    if any(k in q for k in ["electricity", "power", "water", "utility", "utilities"]):
        plot_utility_trends(df)
        plot_electricity_vs_solar_pie(df)
        return

    # Transport / fuel / EV / bus
    if any(k in q for k in ["fuel", "gas", "ev", "transport", "bus", "transit"]):
        plot_fuel_type_breakdown(df)
        plot_fuel_and_transit_mix_pie(df)
        return

    # Solar / green upgrades
    if any(k in q for k in ["solar", "panel", "pv", "heat pump", "upgrade"]):
        plot_solar_investment_timeline(df)
        plot_electricity_vs_solar_pie(df)
        return

    # Recycling / bottle returns / debit vs credit style questions
    if any(k in q for k in ["bottle", "recycle", "reuse", "return"]):
        plot_green_vs_other_spend_pie(df)
        return

    # Fallback: if we have points, show points breakdown; else spend breakdown
    if "Points" in df.columns:
        plot_points_by_category_pie(df)
    else:
        plot_spend_by_category_bar(df)

